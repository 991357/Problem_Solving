package dp;

import java.util.Scanner;

/*
 * /**
 * 아파트를 각 층별로 파란색 또는 노란색 페인트로 칠하되 다음과 같은 규칙으로 칠하려고 한다. 
 * 1. 노란색은 인접한 두 층에 연속하여 사용할 수 있다. 
 * 2. 파란색은 인접한 두 층에 연속하여 사용할 수 없다.
 * 이와 같은 규칙으로 N층의 아파트를 칠 수 있는 방법의 수f(n)을 구하시오  
 * 
 * f(1) = 2
 *  노, 파
 * 
 * f(2) = 3
 * 노노, 노파, 파노
 * 
 * f(3) = 5
 * 노노노, 노노파,  노파노, 파노노, 파노파
 * 
 * f(4) = 8
 * 노노노노, 노노노파, 노노파노, 노파노노, 노파노파, 파노노노, 파노노파, 파노파노  
 * 
 * 
 * 노랑(n) = 노랑(n-1) + 파랑(n-1)
 * 파랑(n) = 노랑(n-1)
 * f(n) = 노랑(n) + 파랑(n)
   f(n) =  노랑(n-1) + 파랑(n-1) + 노랑(n-1)
   f(n) = f(n-1) +  (노랑(n-1)+ -1) + (파랑(n-1)+ -1) 
				   => f(n-2)
 그래서 f(n) =  f(n-1) + f(n-2);				   	
점화식 유도

각 층을 파란색(B) 또는 노란색(Y)으로 칠하는 경우
마지막 층이 노란색(Y) 인 경우: 이전 층이 어떤 색이든 상관없음
마지막 층이 파란색(B) 인 경우: 이전 층이 반드시 노란색(Y)
즉,
마지막 층이 노란색(Y) 으로 끝나는 경우의 개수는 
𝑓(𝑛−1)
마지막 층이 파란색(B) 으로 끝나는 경우의 개수는 
f(n−2)
따라서, 점화식은

f(n)=f(n−1)+f(n−2) 이며, 이는 피보나치 수열과 동일한 구조입니다.


 */
public class dp6_아파트칠하기_상향식
{
    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();

        int[] apt = new int[N + 1];
        apt[1] = 2;
        apt[2] = 3;


        for (int n = 3; n < apt.length; n++)
        {
            // f(n) = f(n-1) + f(n-2)
            apt[n] = apt[n - 1] + apt[n - 2];
        }
        System.out.println(apt[N]);
        sc.close();


//		int N2 = 8;
//		int[][] apt2 = new int[N2][2];
//		apt2[0][0] = 1; // 노랑
//		apt2[0][1] = 1; // 파랑
//		for (int i = 1; i < N; i++) {
//			apt2[i][0] = apt2[i - 1][0] + apt2[i - 1][1];
//			apt2[i][1] = apt2[i - 1][0];
//		}
//		System.out.printf("%d층 까지 칠할 경우의 수 : %d\n", N, apt2[N2 - 1][0] + apt2[N2 - 1][1]);
    }
}
